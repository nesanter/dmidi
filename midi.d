/**
 * MIDI File Parser
 * 
 * This module contains the classes necessary to load
 * and parse a MIDI file into an internal format.
 *
 * Authors: Noah Santer, nesanter@knox.edu
 */

module midi;

import std.stdio;
import std.conv;

/// The type of all exceptions generated by the parser.
class MidiException : Exception {
    this(string msg) {
        super(msg);
    }
}

enum MidiChunkType {
    HEADER,
    TRACK,
    UNKNOWN
}

/**
 * Encapsulates the file access functions
 * that are used to read from raw the MIDI file.
 */
class MidiReadQueue {
    private enum buffer_size = 1024;

    private File f;

    private ubyte[] buffer;
    private ulong index;
    private ulong length;

    private ulong accumulator;
    private ulong accumulator_base;

    /// Create a new stream from an underlying file.
    this(File f) {
        buffer.length = buffer_size;
        this.f = f;
        advance();
    }

    /**
     * Access the internal accumulator that tracks
     * how many bytes have been read since the last reset.
     */
    void reset_amount_read() {
        accumulator_base = accumulator + index;
    }

    /// ditto
    @property ulong amount_read() {
        return (accumulator + index) - accumulator_base;
    }

    /**
     * Test whether the stream has reached the end of
     * the file.
     */
    @property bool empty() {
        return (length == 0);
    }

    private void advance() {
        if (!f.eof) {
            accumulator += length;

            ubyte[] slice = f.rawRead(buffer);
            length = slice.length;
            index = 0;

            if (length < 0) {
                throw new MidiException("Error reading file");
            }
        } else {
            length = 0;
        }
    }

   /**
    * Read n bytes from the stream and return them unchanged
    * in an array.
    *
    * Throws MidiException if the file ends unexpectedly.
    */
    ubyte[] read_bytes(ulong n) {
        if (index + n < length) {
            ubyte[] tmp = buffer[index .. index + n];
            index += n;
            return tmp;
        } else {
            ubyte[] tmp = buffer[index .. length];
            n -= (length - index);
            advance();
            if (n <= length) {
                tmp = tmp ~ buffer[index .. index + n];
                index += n;
                return tmp;
            } else {
                throw new MidiException("Unexpected end of file");
            }
        }
    }

    /**
     * Read one object of type T from the stream return it.
     *
     * The amount of data read is determined by `T.sizeof`.
     * 
     * read() performs a big-to-little endianness conversion,
     * read_raw() does not.
     *
     * Throws: MidiException if the file ends unexpectedly.
     */
    T read_raw(T)() {
        ubyte[] bytes = read_bytes(T.sizeof);

        return *cast(T*)bytes.ptr;
    }

    /// ditto
    T read(T)() {
        ubyte[] bytes = read_bytes(T.sizeof);
        ubyte[] reversed = bytes.reverse;

        return *cast(T*)(reversed.ptr);
    }

    /**
     * Read four bytes from the stream and compare them to
     * the known MIDI chunk identifiers.
     *
     * Known identifiers: 'MThd' and 'MTtk'
     *
     * Throws: MidiException if the file ends unexpectedly.
     * Returns: MidiChunkType.HEADER, MidiChunkType.TRACK,
     * or MidiChunkType.UNKNOWN
     */
    MidiChunkType read_chunk_type() {
        ubyte[] type = read_bytes(4);

        if (type[0] == 'M' && type[1] == 'T') {
            if (type[2] == 'h' && type[3] == 'd') {
                return MidiChunkType.HEADER;
            } else if (type[2] == 'r' && type[3] == 'k') {
                return MidiChunkType.TRACK;
            }
        }

        return MidiChunkType.UNKNOWN;
    }

    /**
     * Read a single variable-length quantity from the stream
     * and return it.
     *
     * read_variable() performs a big-to-little endianness conversion.
     * 
     * Throws: MidiException if the file ends unexpectedly.
     * Returns: A uint from 0x00000000 to 0x0FFFFFFF
     */
    uint read_variable() {
        ubyte[] bytes = read_bytes(1);
        while (bytes[$-1] & 128) {
            bytes ~= read_bytes(1);
        }

        uint x = 0;
        foreach (b; bytes) {
            x = ((x & 127) << 7) | b;
        }

        return x;
    }

    /**
     * Advance the stream by n bytes, discarding the result.
     *
     * Throws: MidiException if the end of the file is reached
     * before n bytes are read.
     */
    void skip(ulong n) {
        while (n > 0) {
            if ((n + index) > length) {
                n = (n + index) - length;
                advance();
                if (length == 0)
                    throw new MidiException("unexpected end of file");
            } else {
                index = n;
                return;
            }
        }
    }

    /**
     * Write a variable-length quantity into a buffer
     *
     * Returns: a pointer to the next element in the buffer
     */
    static ubyte* write_variable(ubyte* buffer, uint n) {
        while (n > 127) {
            *buffer++ = 128 | (n & 127);
            n >>= 7;
        }
        *buffer++ = n & 127;

        return buffer;
    }
}


/**
 * Encapsulates the data from a single MIDI file
 */
class MidiData {
    /**
     * Parses the MIDI file f.
     *
     * Returns: A new MidiData object.
     */
    static MidiData parse_midi_from_file(File f) {
        auto queue = new MidiReadQueue(f);
        auto data = new MidiData(queue);
        return data;
    }

    MidiHeader header;
    MidiTrack[] tracks;

    /**
     * Creates a new data object and automatically
     * parses the data from queue.
     */
    this(MidiReadQueue queue) {
        while (!queue.empty) {
            MidiChunkType chunk_type = queue.read_chunk_type();
            uint length = queue.read!uint();

            final switch (chunk_type) {
                case MidiChunkType.HEADER:
                    if (header !is null) {
                        stderr.writeln("Warning: overwriting previous header");
                    }
                    header = new MidiHeader(queue, length);
                    break;
                case MidiChunkType.TRACK:
                    tracks ~= new MidiTrack(queue, length);
                    break;
                case MidiChunkType.UNKNOWN:
                    queue.skip(length);
                    break;
            }
        }
    }

    /**
     * Print a textual representation of the MIDI data
     */
    void dump() {
        writeln(header);
        foreach (track; tracks) {
            writeln(track);
            track.dump();
        }
    }
}


/**
 * Represents a MIDI header chunk
 */
class MidiHeader {
    /// The type of division encoded in the header
    enum DivisionType {
        PER_QUARTER, /// Division is measured in ticks_per_quarter.
        PER_FRAME /// Division is measured in ticks_per_frame and frames_per_second.
    }
    DivisionType division_type; /// ditto
    /// The underlying header data
    ushort format;
    ushort tracks; /// ditto
    ushort ticks_per_quarter; /// ditto
    ushort frames_per_second; /// ditto
    ushort ticks_per_frame; /// ditto

    this(MidiReadQueue queue, uint length) {
        format = queue.read!ushort();
        tracks = queue.read!ushort();
        ushort division = queue.read!ushort();
        if (division & 0x8000) {
            division_type = DivisionType.PER_FRAME;
            frames_per_second = (division & 0x7F00) >> 8;
            ticks_per_frame = (division & 0x00FF);
        } else {
            division_type = DivisionType.PER_QUARTER;
            ticks_per_quarter = division;
        }

        if (length - 6 > 0)
            queue.skip(length - 6);
    }

    ///
    override string toString() {
        if (division_type == DivisionType.PER_QUARTER) {
            return "Chunk:Header(format = " ~ to!string(format) ~ ", tracks = " ~
                to!string(tracks) ~ ", ticks_per_quarter = " ~
                to!string(ticks_per_quarter) ~ ")";
        } else {
            return "Chunk:Header(format = " ~ to!string(format) ~ ", tracks = " ~
                to!string(tracks) ~ ", frames_per_second = " ~
                to!string(frames_per_second) ~ ", ticks_per_frame = " ~
                to!string(ticks_per_frame) ~ ")";
        }
    }
}

/**
 * Represents a MIDI track chunk
 */
class MidiTrack {
    MidiEvent[] events; /// An array holding all the events in the track.

    this(MidiReadQueue queue, uint length) {
        queue.reset_amount_read();

        while (queue.amount_read < (length - 1)) {
            MidiEvent e = MidiEvent.parse(queue);
            events ~= e;
        }
    }

    /**
     * Print a textual representation of the track data
     */
    void dump() {
        foreach (e; events) {
            writeln(e);
        }
    }

    ///
    override string toString() {
        return "Chunk:Track(n_events = " ~ to!string(events.length) ~ ")";
    }

    /**
     * Create an iterator for this track
     */
    MidiTrackIter create_iter() {
        return new MidiTrackIter(this);
    }
}

/**
 * Represents a MIDI track event
 *
 * All actual events are subclasses of this class.
 */
abstract class MidiEvent {
    /**
     * The time offset of the event relative to the previous one.
     */
    uint delta_time;

    //        enum MidiEvent function(MidiReadQueue,ubyte)[ubyte] event_ctors = [
    //            &Midi

    /// The name of the event.
    @property string name();

    // The MIDI type code of the event
    @property ubyte type();

    static MidiEvent parse(MidiReadQueue queue) {
        uint t = queue.read_variable();
        ubyte type = queue.read!ubyte();

        if ((type & 0xF0) == 0xF0) {
            if ((type & 0x0F) == 0x0F) {
                return MidiMetaEvent.parse(queue, t);
            } else if ((type & 0x0F) == 0x00) {
                return MidiSysExEvent.parse(queue, type, t);
            } else {
                throw new MidiException("Unhandled event type");
            }
        } else {
            return MidiChannelEvent.parse(queue, type, t);
        }
    }

    /**
     * The size of the MIDI data for this event
     */
    @property ulong size();

    /**
     * Write MIDI data for this event into a buffer
     */
    void buffer(ubyte* buffer);
}

/**
 * Represents a MIDI channel event
 */
abstract class MidiChannelEvent : MidiEvent {

    /**
     * The channel and two type-specific event parameters.
     */
    ubyte channel;
    ubyte param1; /// ditto
    ubyte param2; /// ditto

    static MidiChannelEvent parse(MidiReadQueue queue, ubyte type, uint t) {
        ubyte p1 = queue.read!ubyte();
        ubyte p2 = queue.read!ubyte();

        switch (type & 0xF0) {
            case 0x80: return new MidiNoteOffEvent(type & 0xF, p1, p2, t);
            case 0x90: return new MidiNoteOnEvent(type & 0xF, p1, p2, t);
            case 0xA0: return new MidiNoteAftertouchEvent(type & 0xF, p1, p2, t);
            case 0xB0: return new MidiControllerEvent(type & 0xF, p1, p2, t);
            case 0xC0: return new MidiProgramChangeEvent(type & 0xF, p1, p2, t);
            case 0xD0: return new MidiChannelAftertouchEvent(type & 0xF, p1, p2, t);
            case 0xE0: return new MidiPitchBendEvent(type & 0xF, p1, p2, t);
            default: throw new MidiException("Unexpected channel event type ("~to!string(type & 0xF0)~")");
        }
    }

    this(ubyte channel, ubyte param1, ubyte param2, uint t) {
        this.channel = channel;
        this.param1 = param1;
        this.param2 = param2;
        this.delta_time = t;
    }

    ///
    override string toString() {
        return "Event:Channel:"~name~"<+"~to!string(delta_time)~">("~
            to!string(channel)~", "~to!string(param1)~", "~to!string(param2)~")";
    }

    ///
    override @property ulong size() {
        return 3;
    }

    ///
    override void buffer(ubyte* buffer) {
        buffer[0] = type | channel;
        buffer[1] = param1;
        buffer[2] = param2;
    }
}

/**
 * Subclasses of MidiChannelEvent
 */
class MidiNoteOffEvent : MidiChannelEvent {
    override @property string name() { return "NoteOff"; }
    override @property ubyte type() { return 0x80; }

    this(ubyte channel, ubyte param1, ubyte param2, uint t) {
        super(channel, param1, param2, t);
    }

    /*
    void sequence(Fluid fl) {
        auto evt = fl.create_event(false);
        
        fluid_event_noteoff(evt, channel, param1);

        fl.send(evt, delta_time);

        delete_fluid_event(evt);
    }
    */
}

/// ditto
class MidiNoteOnEvent : MidiChannelEvent {
    override @property string name() { return "NoteOn"; };
    override @property ubyte type() { return 0x90; }

    this(ubyte channel, ubyte param1, ubyte param2, uint t) {
        super(channel, param1, param2, t);
    }

    /*
    void sequence(Fluid fl) {
        auto evt_note = fl.create_event(false);
        auto evt_cb = fl.create_event(true);
        
        fluid_event_noteon(evt_note, channel, param1, param2);
        fluid_event_timer(evt_cb, null);

        fl.send(evt_note, delta_time);
        fl.send(evt_cb, 0);

        delete_fluid_event(evt_note);
        delete_fluid_event(evt_cb);
    }
    */
}

/// ditto
class MidiNoteAftertouchEvent : MidiChannelEvent {
    override @property string name() { return "NoteAftertouch"; }
    override @property ubyte type() { return 0xA0; }

    this(ubyte channel, ubyte param1, ubyte param2, uint t) {
        super(channel, param1, param2, t);
    }
//    void sequence(Fluid fl) { }
}

/// ditto
class MidiControllerEvent : MidiChannelEvent {
    override @property string name() { return "Controller"; }
    override @property ubyte type() { return 0xB0; }

    this(ubyte channel, ubyte param1, ubyte param2, uint t) {
        super(channel, param1, param2, t);
    }
//    void sequence(Fluid fl) { }
}

/// ditto
class MidiProgramChangeEvent : MidiChannelEvent {
    override @property string name() { return "ProgramChange"; }
    override @property ubyte type() { return 0xC0; }

    this(ubyte channel, ubyte param1, ubyte param2, uint t) {
        super(channel, param1, param2, t);
    }
//    void sequence(Fluid fl) { }
}

/// ditto
class MidiChannelAftertouchEvent : MidiChannelEvent {
    override @property string name() { return "ChannelAftertouch"; }
    override @property ubyte type() { return 0xD0; }

    this(ubyte channel, ubyte param1, ubyte param2, uint t) {
        super(channel, param1, param2, t);
    }
//    void sequence(Fluid fl) { }
}

///ditto
class MidiPitchBendEvent : MidiChannelEvent {
    override @property string name() { return "PitchBend"; }
    override @property ubyte type() { return 0xE0; }

    this(ubyte channel, ubyte param1, ubyte param2, uint t) {
        super(channel, param1, param2, t);
    }
//    void sequence(Fluid fl) { }
}

/**
 * Represents a MIDI meta event
 */
abstract class MidiMetaEvent : MidiEvent {

    uint length;

    override @property ubyte type() { return 0xF0; }

    @property ubyte subtype();

    static MidiMetaEvent parse(MidiReadQueue queue, uint t) {
        ubyte type = queue.read!ubyte();
        uint l = queue.read_variable();

        switch (type) {
            case 0x00: return new MidiSequenceNumberEvent(queue, l, t);
            case 0x01: return new MidiTextEvent(queue, l, t);
            case 0x02: return new MidiCopyrightNoticeEvent(queue, l, t);
            case 0x03: return new MidiSequenceNameEvent(queue, l, t);
            case 0x04: return new MidiInstrumentNameEvent(queue, l, t);
            case 0x05: return new MidiLyricsEvent(queue, l, t);
            case 0x06: return new MidiMarkerEvent(queue, l, t);
            case 0x07: return new MidiCuePointEvent(queue, l, t);
            case 0x20: return new MidiChannelPrefixEvent(queue, l, t);
            case 0x2F: return new MidiEndOfTrackEvent(queue, l, t);
            case 0x51: return new MidiSetTempoEvent(queue, l, t);
            case 0x54: return new MidiSMPTEOffsetEvent(queue, l, t);
            case 0x58: return new MidiTimeSignatureEvent(queue, l, t);
            case 0x59: return new MidiKeySignatureEvent(queue, l, t);
            case 0x75: return new MidiSequencerSpecificEvent(queue, l, t);
            default: throw new MidiException("Unexpected meta event type");
        }
    }

    this(uint t, uint l) {
        delta_time = t;
        length = l;
    }

    override @property ulong size() {
        return 2 + length;
    }
}

/// Subclasses of MidiChannelEvent
class MidiSequenceNumberEvent : MidiMetaEvent {
    ushort number;

    override @property string name() { return "SequenceNumber"; }
    override @property ubyte subtype() { return 0x00; }

    this(MidiReadQueue queue, uint l, uint t) {
        this.number = queue.read_raw!ushort();
        super(t, l);
    }

    override string toString() {
        return "Event:Meta:"~name~"<+"~to!string(delta_time)~">("~to!string(number)~")";
    }

    override void buffer(ubyte* buffer) {
        buffer[0] = type;
        buffer[1] = subtype;
        buffer = MidiReadQueue.write_variable(buffer, length);
        buffer[0] = (number & 0xFF00) >> 8;
        buffer[1] = (number & 0x00FF);
    }
}

/// ditto
abstract class MidiMetaASCIIEvent : MidiMetaEvent {
    string text;

    this(MidiReadQueue queue, uint l, uint t) {
        ubyte[] raw = queue.read_bytes(l);
        this.text = std.conv.text(cast(char[])raw);
        super(t, l);
    }

    override string toString() {
        return "Event:Meta:"~name~"<+"~to!string(delta_time)~">("~text~")";
    }

    override void buffer(ubyte* buffer) {
        buffer[0] = type;
        buffer[1] = subtype;
        buffer = MidiReadQueue.write_variable(buffer, length);
        foreach (n; 0 .. text.length) {
            buffer[n] = text[n];
        }
    }

}

/// ditto
class MidiTextEvent : MidiMetaASCIIEvent {

    override @property string name() { return "Text"; }
    override @property ubyte subtype() { return 0x01; }

    this(MidiReadQueue queue, uint l, uint t) {
        super(queue, l, t);
    }
}

/// ditto
class MidiCopyrightNoticeEvent : MidiMetaASCIIEvent {

    override @property string name() { return "CopyrightNotice"; }
    override @property ubyte subtype() { return 0x02; }

    this(MidiReadQueue queue, uint l, uint t) {
        super(queue, l, t);
    }
}

/// ditto
class MidiSequenceNameEvent : MidiMetaASCIIEvent {

    override @property string name() { return "SequenceName"; }
    override @property ubyte subtype() { return 0x03; }

    this(MidiReadQueue queue, uint l, uint t) {
        super(queue, l, t);
    }
}

/// ditto
class MidiInstrumentNameEvent : MidiMetaASCIIEvent {

    override @property string name() { return "InstrumentName"; }
    override @property ubyte subtype() { return 0x04; }

    this(MidiReadQueue queue, uint l, uint t) {
        super(queue, l, t);
    }
}

/// ditto
class MidiLyricsEvent : MidiMetaASCIIEvent {

    override @property string name() { return "Lyrics"; }
    override @property ubyte subtype() { return 0x05; }

    this(MidiReadQueue queue, uint l, uint t) {
        super(queue, l, t);
    }
}

/// ditto
class MidiMarkerEvent : MidiMetaASCIIEvent {

    override @property string name() { return "Marker"; }
    override @property ubyte subtype() { return 0x06; }

    this(MidiReadQueue queue, uint l, uint t) {
        super(queue, l, t);
    }
}

/// ditto
class MidiCuePointEvent : MidiMetaASCIIEvent {

    override @property string name() { return "CuePoint"; }
    override @property ubyte subtype() { return 0x07; }

    this(MidiReadQueue queue, uint l, uint t) {
        super(queue, l, t);
    }
}

/// ditto
class MidiChannelPrefixEvent : MidiMetaEvent {

    override @property string name() { return "ChannelPrefix"; }
    override @property ubyte subtype() { return 0x20; }

    ubyte channel; ///

    this(MidiReadQueue queue, uint l, uint t) {
        this.channel = queue.read!ubyte();
        super(t, l);
    }

    override string toString() {
        return "Event:Meta:"~name~"<+"~to!string(delta_time)~">("~to!string(channel)~")";
    }

    override void buffer(ubyte* buffer) {
        buffer[0] = type;
        buffer[1] = subtype;
        buffer = MidiReadQueue.write_variable(buffer, length);
        buffer[2] = channel;
    }
}

/// ditto
class MidiEndOfTrackEvent : MidiMetaEvent {

    override @property string name() { return "EndOfTrack"; }
    override @property ubyte subtype() { return 0x2F; }

    this(MidiReadQueue queue, uint l, uint t) {
        super(t, l);
    }

    override string toString() {
        return "Event:Meta:"~name~"<+"~to!string(delta_time)~">()";
    }

    override void buffer(ubyte* buffer) {
        buffer[0] = type;
        buffer[1] = subtype;
        buffer = MidiReadQueue.write_variable(buffer, length);
    }
}

/// ditto
class MidiSetTempoEvent : MidiMetaEvent {

    override @property string name() { return "SetTempo"; }
    override @property ubyte subtype() { return 0x51; }

    uint microseconds_per_quarter; ///

    this(MidiReadQueue queue, uint l, uint t) {
        ubyte[] raw = queue.read_bytes(3);
        ubyte[] rev = [0];

        foreach_reverse (b; raw) {
            rev ~= b;
        }

        microseconds_per_quarter = *cast(uint*)rev.ptr;

        super(t, l);
    }

    override string toString() {
        return "Event:Meta:"~name~"<+"~to!string(delta_time)~">("~to!string(microseconds_per_quarter)~")";
    }

    override void buffer(ubyte* buffer) {
        buffer[0] = type;
        buffer[1] = subtype;
        buffer = MidiReadQueue.write_variable(buffer, length);
        buffer[0] = microseconds_per_quarter & 0xFF;
        buffer[1] = (microseconds_per_quarter & 0xFF00) >> 8;
        buffer[2] = (microseconds_per_quarter & 0xFF0000) >> 16;
    }
}

/// ditto
class MidiSMPTEOffsetEvent : MidiMetaEvent {

    override @property string name() { return "SMPTEOffset"; }
    override @property ubyte subtype() { return 0x54; }

    ///
    ubyte frame_rate,
          hours,
          minutes,
          seconds,
          frames,
          subframes;

    this(MidiReadQueue queue, uint l, uint t) {
        ubyte h = queue.read!ubyte();

        frame_rate = (h & 0xC0) >> 6;
        hours = (h & 0x20);

        this.minutes = queue.read!ubyte();
        this.seconds = queue.read!ubyte();
        this.frames = queue.read!ubyte();
        this.subframes = queue.read!ubyte();

        super(t, l);
    }

    override string toString() {
        return "Event:Meta:"~name~"<+"~to!string(delta_time)~">("~to!string(frame_rate)~", "~
            to!string(hours)~", "~to!string(minutes)~", "~
            to!string(seconds)~", "~to!string(frames)~", "~
            to!string(subframes)~")";
    }

    override void buffer(ubyte* buffer) {
        buffer[0] = type;
        buffer[1] = subtype;
        buffer = MidiReadQueue.write_variable(buffer, length);
        buffer[0] = ((frame_rate & 0x3) << 6) | hours;
        buffer[1] = minutes;
        buffer[2] = seconds;
        buffer[3] = frames;
        buffer[4] = subframes;
    }
}

/// ditto
class MidiTimeSignatureEvent : MidiMetaEvent {

    override @property string name() { return "TimeSignature"; }
    override @property ubyte subtype() { return 0x58; }

    ///
    ubyte numerator,
          denominator,
          metronome,
          thirtyseconds;

    this(MidiReadQueue queue, uint l, uint t) {
        this.numerator = queue.read!ubyte();
        this.denominator = queue.read!ubyte();
        this.metronome = queue.read!ubyte();
        this.thirtyseconds = queue.read!ubyte();
        
        super(t, l);
    }

    override string toString() {
        return "Event:Meta:"~name~"<+"~to!string(delta_time)~">("~to!string(numerator)~"/"~
            to!string(denominator)~", "~to!string(metronome)~", "~
            to!string(thirtyseconds)~")";
    }

    override void buffer(ubyte* buffer) {
        buffer[0] = type;
        buffer[1] = subtype;
        buffer = MidiReadQueue.write_variable(buffer, length);
        buffer[0] = numerator;
        buffer[1] = denominator;
        buffer[2] = metronome;
        buffer[3] = thirtyseconds;
    }
}

/// ditto
class MidiKeySignatureEvent : MidiMetaEvent {

    override @property string name() { return "KeySignature"; }
    override @property ubyte subtype() { return 0x59; }

    ///
    ubyte key,
          scale;

    this(MidiReadQueue queue, uint l, uint t) {
        this.key = queue.read!ubyte();
        this.scale = queue.read!ubyte();
        
        super(t, l);
    }

    override string toString() {
        return "Event:Meta:"~name~"<+"~to!string(delta_time)~">("~to!string(key)~", "~to!string(scale)~")";
    }

    override void buffer(ubyte* buffer) {
        buffer[0] = type;
        buffer[1] = subtype;
        buffer = MidiReadQueue.write_variable(buffer, length);
        buffer[0] = key;
        buffer[1] = scale;
    }
}

/// ditto
class MidiSequencerSpecificEvent : MidiMetaEvent {

    override @property string name() { return "SequencerSpecific"; }
    override @property ubyte subtype() { return 0x7F; }

    ///
    ubyte[] data;

    this(MidiReadQueue queue, uint l, uint t) {
        this.data = queue.read_bytes(l);
        super(t, l);
    }

    override string toString() {
        return "Event:Meta:"~name~"<+"~to!string(delta_time)~">("~to!string(data)~")";
    }

    override void buffer(ubyte* buffer) {
        buffer[0] = type;
        buffer[1] = subtype;
        buffer = MidiReadQueue.write_variable(buffer, length);
        foreach (n; 0 .. data.length) {
            buffer[n] = data[n];
        }
    }
}

/**
 * Represents a MIDI system exclusive event
 *
 * Note: not currently handled
 */
abstract class MidiSysExEvent : MidiEvent {

    override @property ubyte type() { return 0xF0; }
    ubyte subtype;

    static MidiSysExEvent parse(MidiReadQueue queue, ubyte type, uint t) {
        uint length = queue.read_variable();

        return new MidiDefaultSysExEvent(type, t);
    }

    this(uint t, ubyte sub) {
        delta_time = t;

    }

    ///
    override @property ulong size() {
        return 0;
    }

    ///
    override void buffer(ubyte* buffer) {
        // do nothing
    }
}

/**
 * Subclasses of MidiSysExEvent
 */
class MidiDefaultSysExEvent : MidiSysExEvent {
    override @property string name() { return "Unimplemented"; }

    this(ubyte sub, uint t) {
        super(t, sub);
    }

    override string toString() {
        return "Event:SysEx:"~name~"<+"~to!string(delta_time)~">("~to!string(type)~")";
    }
}

/**
 * Allows iteration through events in a MidiTrack
 */
class MidiTrackIter {
    MidiTrack track;
    ulong pos;

    ///
    this(MidiTrack track) {
        this.track = track;
        pos = 0;
    }

    /**
     * Return the next event and advance the iterator
     */
    MidiEvent pop() {
        if (empty)
            return null;
        else
            return track.events[pos++];
    }

    /**
     * Test if the iterator has reached the end of the track
     */
    @property bool empty() {
        return (pos == track.events.length);
    }
    
    /**
     * Return the next event in the iterator without advancing
     */
    @property MidiEvent front() {
        if (empty)
            return null;
        else
            return track.events[pos];
    }

    /**
     * Reset the iterator to the beginning of the track
     */
    void reset() {
        pos = 0;
    }
}

/**
 * Together with MidiTrackIter allows synchronizing
 * a MidiEvent with a timestamp
 */
abstract class MidiEventBuffer {
    /**
     * Create a new buffer.
     * If tracks is an empty array (the default)
     * all tracks are used to create the buffer
     */
    static MidiEventBuffer create(MidiData data, ulong[] tracks = []) {
        if (tracks.length == 1) {
            return new MidiEventBufferSingle(data.header, data.tracks[tracks[0]]);
        } else if (tracks.length == 0) {
//            return new MidiEventBufferMulti(data.header, data.tracks);
            return null;
        } else {
            /*
            MidiTrack[] a;
            foreach (tr; tracks)
                a ~= data.tracks[tr];
            
            return new MidiEventBufferMulti(data.header, a);
            */
            return null;
        }
    }

    /**
     * Advance the buffer n_frames
     */
    void advance(uint n_frames);

    /**
     * Get the next event from the buffer. Repeated calls
     * will continue to return events until the buffer
     * is empty (ie another call to advance() is needed)
     *
     * Returns: event or null if no events have occured
     */
    MidiEvent pop_next();

    /// Rewind the buffer
    void rewind();

    /**
     * The sample rate used to scale
     * the delta_time of outgoing events
     */
    @property uint sample_rate();
    @property void sample_rate(uint f_s); /// ditto

    /**
     * The accumulated number of frames
     */
    @property uint offset();

    /**
     * Test whether all events have been popped
     */
    @property bool empty();
}

/**
 * Subclasses of MidiEventBuffer
 */
class MidiEventBufferSingle : MidiEventBuffer {
    private MidiTrackIter iter;
    private ulong index;

    enum default_ms_q = 500;

    private const uint t_q;
    private uint ms_q;
    private uint scale;
    private uint _sample_rate;

    private uint _offset;

    this(MidiHeader header, MidiTrack track) {
        iter = track.create_iter();

        index = 0;
        ms_q = default_ms_q;
        _offset = 0;

        if (header.division_type == MidiHeader.DivisionType.PER_QUARTER)
            t_q = header.ticks_per_quarter;
        else
            throw new MidiException("Unhandled header division type");
    }

    override void advance(uint n_frames) {
        index += n_frames;
    }

    override MidiEvent pop_next() {
        if (iter.empty)
            return null;

        uint dt = iter.front.delta_time * scale;

        if (dt < index) {
//            _offset += dt;
            _offset = dt;
            index -= dt;

            return iter.pop();
        }

        return null;
    }

    override void rewind() {
        index = 0;
        ms_q = default_ms_q;
        _offset = 0;

        iter.reset();
    }

    override @property uint sample_rate() {
        return _sample_rate;
    }

    override @property void sample_rate(uint f_s) {
        _sample_rate = f_s;
        scale = (f_s * ms_q) / (1000 * t_q);
    }

    override @property uint offset() {
        return _offset;
    }

    override @property bool empty() {
        return iter.empty;
    }
}

